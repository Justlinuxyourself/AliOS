--- FILE: ata.c ---
#include "hardware.h"
#include "common.h" // for outb/inb/terminal_write

void detect_ata() {
    // Select Master drive on Primary Bus (Port 0x1F6)
    outb(0x1F6, 0xA0); 
    
    // Send the IDENTIFY command (0xEC)
    outb(0x1F7, 0xEC); 

    // Wait for status
    uint8_t status = inb(0x1F7);
    if (status == 0) {
        terminal_write("[    0.050] ATA: No drive detected on primary bus.\n");
        return;
    }

    // Wait for the drive to clear the Busy bit and set Data Request
    while (inb(0x1F7) & 0x80); 
    
    terminal_write("[    0.120] ATA: HARD DISK FOUND YIPPIE\n");
}


--- FILE: cpu.c ---
#include "hardware.h"
#include "common.h" // for your terminal_write

void detect_cpu() {
    uint32_t ebx, edx, ecx;
    // Leaf 0: Get Vendor ID
    __asm__ volatile("cpuid" 
                     : "=b"(ebx), "=d"(edx), "=c"(ecx) 
                     : "a"(0));

    char vendor[13];
    vendor[12] = '\0';
    // The string is returned across 3 registers
    *(uint32_t*)(vendor) = ebx;
    *(uint32_t*)(vendor + 4) = edx;
    *(uint32_t*)(vendor + 8) = ecx;

    terminal_write("[    0.001] CPU: Detected Vendor: ");
    terminal_write(vendor);
    terminal_write(" YAY\n");
}

void detect_cpu_brand() {
    uint32_t regs[4]; // eax, ebx, ecx, edx
    char brand[49];   // 3 calls * 16 bytes + null terminator
    brand[48] = '\0';

    for (uint32_t i = 0; i < 3; i++) {
        // We use the extended leaves 0x80000002 through 0x80000004
        __asm__ volatile("cpuid" 
                         : "=a"(regs[0]), "=b"(regs[1]), "=c"(regs[2]), "=d"(regs[3]) 
                         : "a"(0x80000002 + i));
        
        // Copy the 16 bytes from registers into our string
        for (int j = 0; j < 4; j++) {
            ((uint32_t*)brand)[(i * 4) + j] = regs[j];
        }
    }

    terminal_write("[    0.002] CPU Model: ");
    terminal_write(brand);
    terminal_write(" YAY\n");
}


--- FILE: gdt.c ---
#include <stdint.h>

struct gdt_entry_struct {
    uint16_t limit_low;
    uint16_t base_low;
    uint8_t  base_middle;
    uint8_t  access;
    uint8_t  granularity;
    uint8_t  base_high;
} __attribute__((packed));

struct gdt_ptr_struct {
    uint16_t limit;
    uint32_t base;
} __attribute__((packed));

struct gdt_entry_struct gdt_entries[5];
struct gdt_ptr_struct   gdt_ptr;

void gdt_set_gate(int32_t num, uint32_t base, uint32_t limit, uint8_t access, uint8_t gran) {
    gdt_entries[num].base_low    = (base & 0xFFFF);
    gdt_entries[num].base_middle = (base >> 16) & 0xFF;
    gdt_entries[num].base_high   = (base >> 24) & 0xFF;

    gdt_entries[num].limit_low   = (limit & 0xFFFF);
    gdt_entries[num].granularity = (limit >> 16) & 0x0F;
    gdt_entries[num].granularity |= gran & 0xF0;
    gdt_entries[num].access      = access;
}

void init_gdt() {
    gdt_ptr.limit = (sizeof(struct gdt_entry_struct) * 5) - 1;
    gdt_ptr.base  = (uint32_t)&gdt_entries;

    gdt_set_gate(0, 0, 0, 0, 0);                // Null segment
    gdt_set_gate(1, 0, 0xFFFFFFFF, 0x9A, 0xCF); // Code segment
    gdt_set_gate(2, 0, 0xFFFFFFFF, 0x92, 0xCF); // Data segment

    // This assembly function loads the GDT
    gdt_flush((uint32_t)&gdt_ptr);
}


--- FILE: idt.c ---
#include <stdint.h>
extern void irq1(); // Add this line at the top of the file




struct idt_entry_struct {
    uint16_t base_lo;             // The lower 16 bits of the address to jump to
    uint16_t sel;                 // Kernel segment selector (usually 0x08)
    uint8_t  always0;             // This must always be zero
    uint8_t  flags;               // Flags (Type of gate, privilege level, etc)
    uint16_t base_hi;             // The upper 16 bits of the address
} __attribute__((packed));

struct idt_ptr_struct {
    uint16_t limit;
    uint32_t base;
} __attribute__((packed));

struct idt_entry_struct idt_entries[256];
struct idt_ptr_struct   idt_ptr;

// Function to set an individual gate
void idt_set_gate(uint8_t num, uint32_t base, uint16_t sel, uint8_t flags) {
    idt_entries[num].base_lo = base & 0xFFFF;
    idt_entries[num].base_hi = (base >> 16) & 0xFFFF;
    idt_entries[num].sel     = sel;
    idt_entries[num].always0 = 0;
    idt_entries[num].flags   = flags;
}

extern void idt_flush(uint32_t);
extern void isr0();

void init_idt() {
    idt_ptr.limit = (sizeof(struct idt_entry_struct) * 256) - 1;
    idt_ptr.base  = (uint32_t)&idt_entries;

    // Zero out the IDT entries to be safe
    for (int i = 0; i < 256; i++) {
        idt_set_gate(i, 0, 0, 0);
    }

    idt_flush((uint32_t)&idt_ptr);


     
    // 0x8E = 10001110 (Present, Ring 0, Lower bits 0, Interrupt Gate)
    idt_set_gate(0, (uint32_t)isr0, 0x08, 0x8E); 
    
    idt_flush((uint32_t)&idt_ptr);
 
    idt_set_gate(33, (uint32_t)irq1, 0x08, 0x8E);
}


--- FILE: isr.c ---
#include <stdint.h>
#include "snake.h"
#include "common.h"

int shift_pressed = 0;
int caps_lock = 0;

extern void handle_shell_input(char c);

// The standard map
unsigned char kbd_us[128] = {
    0,  27, '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '=', '\b',
    '\t', 'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', '[', ']', '\n',
    0, 'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', ';', '\'', '`',   0,
    '\\', 'z', 'x', 'c', 'v', 'b', 'n', 'm', ',', '.', '/',   0, '*', 0, ' '
};

// The shifted map
unsigned char kbd_us_shift[128] = {
    0,  27, '!', '@', '#', '$', '%', '^', '&', '*', '(', ')', '_', '+', '\b',
    '\t', 'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P', '{', '}', '\n',
    0, 'A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', ':', '\"', '~',   0,
    '|', 'Z', 'X', 'C', 'V', 'B', 'N', 'M', '<', '>', '?',   0, '*', 0, ' '
};


extern void terminal_write(const char* data);

// This is a simple error handler for now
void isr_handler() {
    // We'll use your terminal functions to print the error
    terminal_write("SYSTEM EXCEPTION: The kernel has halted to prevent damage.\n");
    while(1); 
}

void keyboard_handler(struct regs *r) {
    // Read the scancode from the keyboard data port
    uint8_t scancode = inb(0x60);

    // 1. Handle Key Release (Break Codes)
    // We ignore releases (7th bit set) to prevent double-typing
    if (scancode & 0x80) {
        // Handle shift release if you have shift logic
        if (scancode == 0xAA || scancode == 0xB6) shift_pressed = 0;
        return; 
    }

    // 2. Handle Special Keys
    if (scancode == 0x2A || scancode == 0x36) { shift_pressed = 1; return; }

    // 3. Convert Scancode to ASCII
    // Use your existing kbd_us array
    char c = shift_pressed ? kbd_us_shift[scancode] : kbd_us[scancode];

    // 4. Send to Shell
    if (c != 0) {
        handle_shell_input(c); 
    }
}


--- FILE: kernel.c ---
#include <stdint.h>
#include <stddef.h>
#include "common.h"
#include "hardware.h"

// Track all 128 possible scancodes (0 = up, 1 = down)
uint8_t key_states[128] = {0};

// 0heh. input/cmd buffer
char command_buffer[256];  // Changed from input_buffer
size_t command_len = 0;    // Changed from input_index
// 1. VGA Settings
static const size_t VGA_WIDTH = 80;
static const size_t VGA_HEIGHT = 25;

// 2. Terminal State (Merged into one place)
uint16_t* terminal_buffer = (uint16_t*) 0xB8000; // Fixed: now points to VGA memory
size_t terminal_row = 0;
size_t terminal_column = 0;
uint8_t terminal_color = 0x07; // Light grey on black

// 3. Prototypes (So terminal_write can see putchar)
void terminal_putchar(char c);
void update_cursor(int x, int y);
// Add this near the top of kernel.c
void terminal_initialize(void);

void play_note(uint32_t freq, int duration) {
    play_sound(freq);
    delay(duration);
    nosound();
    delay(5); // Tiny pause so notes don't mush together
}

void play_sound(uint32_t nFrequence) {
    uint32_t Div;
    uint8_t tmp;

    // Set the PIT to the desired frequency
    Div = 1193180 / nFrequence;
    outb(0x43, 0xb6); // Command: Channel 2, LSB/MSB, Square Wave
    outb(0x42, (uint8_t) (Div) );
    outb(0x42, (uint8_t) (Div >> 8));

    // Read port 0x61 and set bits 0 and 1 to enable speaker
    tmp = inb(0x61);
    if (tmp != (tmp | 3)) {
        outb(0x61, tmp | 3);
    }
}

void play_startup_sound() {
    // A rising melody: C4 -> E4 -> G4 -> C5
    play_note(261, 15); // C4
    play_note(329, 15); // E4
    play_note(392, 15); // G4
    play_note(523, 30); // C5 (higher and longer)
}

void nosound() {
    uint8_t tmp = inb(0x61) & 0xFC; // Mask bits 0 and 1 to 0
    outb(0x61, tmp);
}

void handle_shell_input(char c) {
    if (c == '\n') {
        terminal_putchar('\n');             // Move cursor to new line
        command_buffer[command_len] = '\0'; // Properly seal the string
        
        execute_command(command_buffer);    // Process what was typed
        
        command_len = 0;                    // Reset for next time
        memset(command_buffer, 0, 256);
    } 
    else if (c == '\b') {
        if (command_len > 0) {
            command_len--;                  // Remove from memory
            terminal_putchar('\b');         // Remove from screen
        }
    } 
    else {
        if (command_len < 255) {
            command_buffer[command_len++] = c; // Save to buffer
            terminal_putchar(c);               // Show on screen
        }
    }
}

void execute_command(char* input) {
    if (strcmp(input, "help") == 0) {
        terminal_write("Commands: help, cls, halt, reboot, beep\n");
    }  
    else if (strcmp(input, "cls") == 0) {
        terminal_initialize();
    }
    else if (strcmp(input, "halt") == 0) {
        terminal_write("System Halting. Goodbye!\n");
        // Disable interrupts so the CPU truly stops
        __asm__ volatile("cli"); 
        // Put CPU in sleep state
        while(1) { __asm__ ("hlt"); } 
    }
    else if (strcmp(input, "reboot") == 0) {
    terminal_write("Rebooting...\n");
    uint8_t good = 0x02;
    while (good & 0x02)
        good = inb(0x64);
    outb(0x64, 0xFE); // Pulse the CPU reset line
    } else if (strcmp(input, "beep") == 0) {
    terminal_write("Testing PIT Speaker...\n");
    play_sound(1000); // 1000Hz tone
    delay(50);        // Wait
    nosound();       // Stop
    } else if (input[0] != '\0') {
        terminal_write("Err: command not found\n");
    }

    terminal_write("SHELL> ");
}

void delay(int ticks) {
    for (volatile int i = 0; i < ticks * 100000; i++) {
        // The 'volatile' keyword prevents the compiler from 
        // optimizing this loop away.
        __asm__("nop"); 
    }
}

void terminal_putentryat(char c, uint8_t color, size_t x, size_t y) {
    const size_t index = y * VGA_WIDTH + x;
    terminal_buffer[index] = (uint16_t) c | (uint16_t) color << 8;
}

// 4. Initialization Logic
void terminal_initialize(void) {
    terminal_row = 0;
    terminal_column = 0;
    terminal_color = 0x07;
    for (size_t i = 0; i < VGA_WIDTH * VGA_HEIGHT; i++) {
        terminal_buffer[i] = (uint16_t)' ' | (uint16_t)terminal_color << 8;
    }
}

void append_to_buffer(char c) {
    if (command_len < 255) {
        command_buffer[command_len++] = c;
        command_buffer[command_len] = '\0';
    }
}

void clear_buffer() {
    // Use memset to be safe, or just reset the index
    command_len = 0;
    command_buffer[0] = '\0';
}


// 5. Cursor Logic
void update_cursor(int x, int y) {
    uint16_t pos = y * VGA_WIDTH + x;
    outb(0x3D4, 0x0F);
    outb(0x3D5, (uint8_t) (pos & 0xFF));
    outb(0x3D4, 0x0E);
    outb(0x3D5, (uint8_t) ((pos >> 8) & 0xFF));
}



// 6. Putchar Logic (Handles scrolling and newlines)
void terminal_putchar(char c) {
    if (c == '\n') {
        terminal_column = 0;
        terminal_row++;
    } 
    else if (c == '\b') {
        // Visual backspace: move back and print a space
        if (terminal_column > 0) {
            terminal_column--;
            const size_t index = terminal_row * VGA_WIDTH + terminal_column;
            terminal_buffer[index] = (uint16_t)' ' | (uint16_t)terminal_color << 8;
        }
    } 
    else {
        // Standard character printing
        const size_t index = terminal_row * VGA_WIDTH + terminal_column;
        terminal_buffer[index] = (uint16_t)c | (uint16_t)terminal_color << 8;
        terminal_column++;
    }

    // Wrap-around logic
    if (terminal_column >= VGA_WIDTH) {
        terminal_column = 0;
        terminal_row++;
    }

    // Scrolling logic
    if (terminal_row >= VGA_HEIGHT) {
        for (size_t y = 0; y < VGA_HEIGHT - 1; y++) {
            for (size_t x = 0; x < VGA_WIDTH; x++) {
                terminal_buffer[y * VGA_WIDTH + x] = terminal_buffer[(y + 1) * VGA_WIDTH + x];
            }
        }
        // Clear the new last line
        for (size_t x = 0; x < VGA_WIDTH; x++) {
            terminal_buffer[(VGA_HEIGHT - 1) * VGA_WIDTH + x] = (uint16_t)' ' | (uint16_t)terminal_color << 8;
        }
        terminal_row = VGA_HEIGHT - 1;
    }

    update_cursor(terminal_column, terminal_row);
}
// 7. Write Function (Exported for isr.c)
void terminal_write(const char* data) {
    for (size_t i = 0; data[i] != '\0'; i++) {
        terminal_putchar(data[i]);
    }
}

// 8. The Entry Point (Matches 'call kernel_main' in boot.s)
extern void init_gdt();
extern void init_idt();
extern void pic_remap();

void kernel_main(void) {
    init_gdt();
    init_idt();
    pic_remap();
    terminal_initialize();

    terminal_write("Booting AliOS...\n");

    // Real Hardware Detection
    detect_cpu();    // Asks the CPU "Who are you?"
    detect_cpu_brand();
    detect_ata();    // Asks the Hard Drive "Are you there?"
    probe_pci();

    terminal_write("\nInitialization Complete. Starting Shell.\n");
    terminal_write("> ");
    play_startup_sound();
    __asm__ volatile("sti");
    while(1) { __asm__ ("hlt"); }
}


--- FILE: pci.c ---
#include "hardware.h"
#include "common.h"

// Helper to read PCI configuration space
uint16_t pci_config_read_word(uint8_t bus, uint8_t slot, uint8_t func, uint8_t offset) {
    uint32_t address;
    uint32_t lbus  = (uint32_t)bus;
    uint32_t lslot = (uint32_t)slot;
    uint32_t lfunc = (uint32_t)func;
    uint16_t tmp = 0;

    // Create configuration address
    address = (uint32_t)((lbus << 16) | (lslot << 11) |
              (lfunc << 8) | (offset & 0xfc) | ((uint32_t)0x80000000));

    outl(0xCF8, address);
    // (uint16_t)((inl(0xCFC) >> ((offset & 2) * 8)) & 0xffff)
    tmp = (uint16_t)((inl(0xCFC) >> ((offset & 2) * 8)) & 0xffff);
    return (tmp);
}

void probe_pci() {
    terminal_write("[    0.150] PCI: Probing PCI bus...\n");
    for(uint32_t bus = 0; bus < 256; bus++) {
        for(uint32_t slot = 0; slot < 32; slot++) {
            uint16_t vendor = pci_config_read_word(bus, slot, 0, 0);
            if(vendor != 0xFFFF) {
                uint16_t device = pci_config_read_word(bus, slot, 0, 2);
                
                terminal_write("Found PCI Device: Vendor 0x8086 Device 0x1237\n");
                // (Optional: You can use a hex-to-string function here later)
            }
        }
    }
}


--- FILE: pic.c ---
#include <stdint.h>


static inline void outb(uint16_t port, uint8_t val) {
    __asm__ volatile ( "outb %b0, %w1" : : "a"(val), "Nd"(port) : "memory");
}

void pic_remap() {
    // ICW1: Start initialization in cascade mode
    outb(0x20, 0x11);
    outb(0xA0, 0x11);

    // ICW2: Vector offsets (Map IRQ 0-7 to 32-39, and IRQ 8-15 to 40-47)
    outb(0x21, 0x20); 
    outb(0xA1, 0x28);

    // ICW3: Tell Master PIC there is a slave PIC at IRQ2
    outb(0x21, 0x04);
    outb(0xA1, 0x02);

    // ICW4: Set 8086 mode
    outb(0x21, 0x01);
    outb(0xA1, 0x01);

    // Mask all interrupts except the keyboard (IRQ 1) for now
    // 0xFD = 11111101 (Only bit 1 is 0/enabled)
    outb(0x21, 0xFD); 
    outb(0xA1, 0xFF);
}


--- FILE: snake.c ---
#include "common.h"
int score = 0;

#define MAX_SNAKE_LENGTH 100
#define BOARD_WIDTH 80
#define BOARD_HEIGHT 25
int game_running = 0;
struct Point {
    int x, y;
};
void terminal_putentryat(char c, uint8_t color, size_t x, size_t y);
struct Point snake[MAX_SNAKE_LENGTH];
int snake_length = 3;
int dx = 1, dy = 0; // Starting direction (moving right)
struct Point food;

void place_food() {
    // In a real kernel, you'd use a random number generator
    // For now, we'll just pick a spot
    food.x = 20;
    food.y = 10;
}

void move_snake() {
    // 1. Body segments follow the head
    for (int i = snake_length - 1; i > 0; i--) {
        snake[i].x = snake[i - 1].x;
        snake[i].y = snake[i - 1].y;
    }
    // 2. Apply the direction chosen by update_direction
    snake[0].x += dx;
    snake[0].y += dy;
}

void draw_snake() {
    for (int i = 0; i < snake_length; i++) {
        // Draw each segment as an 'O'
        terminal_putentryat('O', 0x0A, snake[i].x, snake[i].y);
    }
    // Draw food as an '*'
    terminal_putentryat('*', 0x0C, food.x, food.y);
}

void update_direction(char c) {
    // DEBUG: This will draw the key you pressed at the top-right corner.
    // If you don't see the letter appear, your isr.c isn't calling this!
    terminal_putentryat(c, 0x0E, 79, 0); 

    // Handle WASD (Lowercase and Uppercase)
    // The '&& dy == 0' part prevents the snake from reversing into itself
    if ((c == 'w' || c == 'W') && dy == 0) {
        dx = 0; 
        dy = -1;
    } else if ((c == 's' || c == 'S') && dy == 0) {
        dx = 0; 
        dy = 1;
    } else if ((c == 'a' || c == 'A') && dx == 0) {
        dx = -1; 
        dy = 0;
    } else if ((c == 'd' || c == 'D') && dx == 0) {
        dx = 1; 
        dy = 0;
    }
    
    // Optional: Press 'q' to quit the game manually
    if (c == 'q' || c == 'Q') {
        game_running = 0;
    }
}

void run_snake_game() {
    game_running = 1;
    score = 0;
    snake_length = 3;
    
    // Reset starting position and direction
    snake[0].x = 40; snake[0].y = 12; 
    dx = 1; dy = 0; 
    
    place_food(); // Ensure food has a position

    while(game_running) {
        move_snake();

        // --- WALLS ---
        if (snake[0].x < 0 || snake[0].x >= 80 || snake[0].y < 0 || snake[0].y >= 25) {
            game_running = 0;
            break; 
        }

        // --- SCORE & EATING ---
        if (snake[0].x == food.x && snake[0].y == food.y) {
            score += 1;
            snake_length++;
            place_food(); 
        }

        terminal_initialize(); // Clear previous frame
        
        // Draw Score at (0,0)
        terminal_putentryat('S', 0x07, 0, 0);
        terminal_putentryat((score % 10) + '0', 0x0E, 1, 0); 
        
        draw_snake(); // Draws 'O' for snake and '*' for food
        
        delay(60); // Use a high value so you can actually see it move
    }
}


--- FILE: string.c ---
#include <stdint.h>
#include <stddef.h>

// Compares two strings. Returns 0 if they are equal.
int strcmp(const char* s1, const char* s2) {
    while (*s1 && (*s1 == *s2)) {
        s1++;
        s2++;
    }
    return *(const unsigned char*)s1 - *(const unsigned char*)s2;
}

// Returns the length of a string.
size_t strlen(const char* str) {
    size_t len = 0;
    while (str[len]) {
        len++;
    }
    return len;
}

void* memset(void* bufptr, int value, size_t size) {
    unsigned char* buf = (unsigned char*) bufptr;
    for (size_t i = 0; i < size; i++) {
        buf[i] = (unsigned char) value;
    }
    return bufptr;
}


--- FILE: common.h ---
#ifndef COMMON_H
#define COMMON_H

#include <stdint.h>
#include <stddef.h>

extern uint8_t key_states[];

// Kernel functions used by snake
void terminal_initialize(void);
void terminal_putentryat(char c, uint8_t color, size_t x, size_t y);
void delay(int ticks);

// I/O Port Helpers
static inline void outb(uint16_t port, uint8_t val) {
    __asm__ volatile ( "outb %b0, %w1" : : "a"(val), "Nd"(port) : "memory");
}

static inline uint8_t inb(uint16_t port) {
    uint8_t ret;
    __asm__ volatile ( "inb %w1, %b0" : "=a"(ret) : "Nd"(port) : "memory");
    return ret;
}

static inline void outl(uint16_t port, uint32_t val) {
    __asm__ volatile ( "outl %0, %w1" : : "a"(val), "Nd"(port) );
}

static inline uint32_t inl(uint16_t port) {
    uint32_t ret;
    __asm__ volatile ( "inl %w1, %0" : "=a"(ret) : "Nd"(port) );
    return ret;
}

int strcmp(const char* s1, const char* s2);
size_t strlen(const char* str);

void* memset(void* bufptr, int value, size_t size);

// Terminal Exports (so isr.c can see them)
extern void terminal_write(const char* data);
extern void terminal_putchar(char c);

#endif


--- FILE: hardware.h ---
#ifndef HARDWARE_H
#define HARDWARE_H

#include <stdint.h>

// CPU Detection
void detect_cpu();

// ATA Disk Detection
void detect_ata();

// PCI Bus Probing
void probe_pci();

#endif


--- FILE: snake.h ---
extern int game_running;
void update_direction(char c);


--- FILE: boot.s ---
/* Declare constants for the multiboot header. */
.set ALIGN,    1<<0             
.set MEMINFO,  1<<1             
.set FLAGS,    ALIGN | MEMINFO  
.set MAGIC,    0x1BADB002       
.set CHECKSUM, -(MAGIC + FLAGS) 

.section .multiboot
.align 4
.long MAGIC
.long FLAGS
.long CHECKSUM

/* Allocate room for a small stack. */
.section .bss
.align 16
stack_bottom:
.skip 16384 # 16 KiB
stack_top:

.section .text
.global _start
_start:
	mov $stack_top, %esp    # This is the "Ears" of the CPU we need for C
	call kernel_main

	cli
1:	hlt
	jmp 1b

.global gdt_flush
gdt_flush:
    mov 4(%esp), %eax
    lgdt (%eax)
    mov $0x10, %ax      # 0x10 is the offset to our data segment
    mov %ax, %ds
    mov %ax, %es
    mov %ax, %fs
    mov %ax, %gs
    mov %ax, %ss
    ljmp $0x08, $.flush # 0x08 is the offset to our code segment
.flush:
    ret

.global idt_flush
idt_flush:
    mov 4(%esp), %eax
    lidt (%eax)        # Load the IDT pointer
    ret

# ... (Keep your Multiboot and GDT/IDT flush code) ...

# --- Macros ---
.macro ISR_NOERRCODE num
  .global isr\num
  isr\num:
    cli
    push $0
    push $\num
    jmp isr_common_stub
.endm

.macro IRQ num, target
  .global irq\num
  irq\num:
    cli
    push $0
    push $\target
    jmp irq_common_stub
.endm

# --- Define the ISRs and IRQs ---
ISR_NOERRCODE 0
IRQ 1, 33

# --- Exception Stub (For CPU Errors) ---
.extern isr_handler
isr_common_stub:
    pusha
    mov %ds, %ax
    push %eax
    mov $0x10, %ax
    mov %ax, %ds
    mov %ax, %es
    mov %ax, %fs
    mov %ax, %gs
    call isr_handler    # Calls the exception handler in isr.c
    pop %eax
    mov %ax, %ds
    mov %ax, %es
    mov %ax, %fs
    mov %ax, %gs
    popa
    add $8, %esp
    iret

# --- Hardware Stub (For Keyboard) ---
.extern keyboard_handler
.global irq_common_stub
irq_common_stub:
    pusha
    mov %ds, %ax
    push %eax
    mov $0x10, %ax
    mov %ax, %ds
    mov %ax, %es
    mov %ax, %fs
    mov %ax, %gs
    call keyboard_handler # Calls the keyboard handler in isr.c
    pop %eax
    mov %ax, %ds
    mov %ax, %es
    mov %ax, %fs
    mov %ax, %gs
    popa
    add $8, %esp
    iret

